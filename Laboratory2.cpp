#include <iostream>
#define _CRT_SECURE_NO_WARNINGS
#include <math.h>
#include < stdio.h >

//Лабораторна робота 2
//Виконав Кот Олександр Анатолійович, 3 курс бакалавра ННІВТ, біолог
//Варіант 2
// 1)	Використовуючи один із циклічних операторів знайти безпосереднім розрахунком суму 
//      ряду, тобто 2^(0) + 2^(1) + 2^(2) + ... + 2^(N-1) (число N задається введенням з 
//		клавіатури). Записати результат у змінну А.
// 
// 
// 2)	Порівняти отримане число з теоретично виведеною формулою 2^(N)-1.Записати результат у змінну В.
// 
// 
// 3)	Вивести на екран значення змінних А та В.
// 
// 
// 4)	Використовуючи умовний оператор, порівняти отримані числа.Якщо А = В вивести
//      на екран фразу «Дорівнюють», якщо А > В – «Сума більше», А < В – «Сума менше».
// 
// 
// 5)	Побудуйте другий варіант програми.Реалізуйте цикл з пункту 1, використовуючи оператор 
//      goto: приклад
//		«мітка :
//		тіло циклу;
//		if (умова) goto мітка;»
// 
// 
// 6)	Продемонструвати роботу програми викладачу.

// Хід роботи:
int main()
{
	// 1)	Використовуючи один із циклічних операторів знайти безпосереднім розрахунком суму 
	//      ряду, тобто 2^(0) + 2^(1) + 2^(2) + ... + 2^(N-1) (число N задається введенням з 
	//		клавіатури). Записати результат у змінну А.
	int N;
	printf_s ("Enter an integer N:\t"); 
	scanf_s("%i", &N);
	int A = 0;


	// Цикл для сумування усіх доданків(двійок з разними степенями)
	for (int i = N-1; i >= 0; i--) 
	{
		// ініціалізація змінної яка зберігає один з доданків (двійка в якійсь
		//степені окрім 0 та 1) і при кожній новій ітерації temp буде присвоюватися 2
		int temp = 2; 


		// якщо і = 0, це означає що це 2^(0) = 1, тому одразу як бачимо цю ситуацію просто додаємо 1 до змінної А
		if (i == 0) 
		{
			A += 1;
		}
		// означаж 2^(1) = 2, тому просто додаємо 2
		else if (i == 1)
		{
			A += 2;
		}
		else {
			// а це вкладенний цикл який рахує усі доданки починаючи з 2^(2) і до 2^(N-1) включно
			for (int q = i; q > 1; q--) 
			{
				temp *= 2;
			}
			// додаємо змінну темп до основної змінної А і після цього починаємо
			// все з початку - temp знову буде = 2, а А буде зберігати данні до кінця роботи програми
			A += temp;
		}
	}


	// 2)	Порівняти отримане число з теоретично виведеною формулою 2^(N)-1.Записати результат у змінну В.
	// 
	// 
	//оголошуємо нову змінну В та ініціалізуємо зі значенням 1, 
	//бо будемо далі множити постійно двійку на цю ж змінну тому
	//нам треба обов'язково початкове значення, а саме 1 при множинні ні на що не впливає
	int B = 1; 
	// Блок кода, що реалізує формулу 2^(N)-1
	for (int w = N; w > 0; w--)
	{
		B *= 2;
	}
	B -= 1;


	//3)	Вивести на екран значення змінних А та В.
	printf_s(" A = %i, B = %i\n", A, B);



	// 4)	Використовуючи умовний оператор, порівняти отримані числа.Якщо А = В вивести
	//      на екран фразу «Дорівнюють», якщо А > В – «Сума більше», А < В – «Сума менше».
	if (A>B)
	{
		printf_s(" A > B\n");
	}
	else if (A == B)
	{
		printf_s(" A = B\n");
	}
	else 
	{
		printf_s(" A < B\n");
	}


	// 5)	Побудуйте другий варіант програми.Реалізуйте цикл з пункту 1, використовуючи оператор 
	//      goto: приклад
	//		«мітка :
	//		тіло циклу;
	//		if (умова) goto мітка;»


	//	Щоб зайвий раз не коментувати та розкоментовувати, я просто зроблю точно таку ж за призначенням программу, 
	//	яка буде працювати одразу після минулої, єдина різниця в використанні міток та інших ідентифікаторів для змінних
	
	int N2;
	printf_s("Enter another integer N2: \t");
	scanf_s("%i", &N2);
	int A2 = 0;
	int temp2 = 2;
	int B2 = 1;
	int r = N2;



cycle:
	//Цикл дивиться, якщо N2 = 2, то просто додаємо 3
	if (N2 == 2)
	{
		A2 += 3;
		goto secondstep;
	}
	// якщо ми дійшли до цього момента, тоді N>2 , тому починаємо рахувати чому буде дорівнювати 2^(N-1)
	else {
		for (int e = N2 - 1; e > 1; e--)
		{
			temp2 *= 2;
		}
		// додаємо ну а тепер додаємо проміжний результат до відповіді і повторюємо все заново
		A2 += temp2;
		temp2 = 2;
		N2--;
		goto cycle;
	}
	
	// А тепер ще раз пишемо блок кода, що реалізує формулу 2^(N)-1
secondstep:

	for (int p = r; p > 0; p--)
	{
		B2 *= 2;
	}
	B2 -= 1;


	printf_s(" A2 = %i, B2 = %i\n", A2, B2);

	if (A2 > B2)
	{
		printf_s(" A2 > B2\n");
	}
	else if (A2 == B2)
	{
		printf_s(" A2 = B2\n");
	}
	else
	{
		printf_s(" A2 < B2\n");
	}

}

